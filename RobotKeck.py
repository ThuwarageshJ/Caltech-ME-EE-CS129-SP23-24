"""
    Caltech ME/EE/CS129 - Experimental Robotics - Spring 23/24 
    Team Robo-TEd
    Contributors: Thuwaragesh Jayachandran, Edward Ju

    Main Robot Code. 

    UI commands:
    (1) Manual driving: 'straight', 'right', 'drive'
    (2) Undirected exploration: 'explore'
    (3) Traverse to a known/ unknown goal: 'goal {x_goal} {y_goal}'
    (4) Pause while in (2) or (3): 'pause'
    (5) Execute a single step of (2)/(3) while in (4): 'step'
    (6) Resume to (2)/(3) from (4): 'resume'
    (7) Clear blockages marked on map: 'clear'
    (8) Load an empty map: 'load n {x_initial} {y_initial} {heading_initial}'
    (9) Reset coordinates: 'pose {x_new} {y_new} {heading_new}'
    (10) Load a map saved in /maps: 'load {filename}.pickle'
    (11) Save the current map in /maps: 'save {filename}'

    heading is an integer modulus 8 for a right handed orientation
"""

import pigpio
import sys
import time
import traceback
from linesensor import LineSensor
from drivesystem import DriveSystem
from anglesensor import AngleSensor
from streetmap import STATUS, Map
from proximitysensor import ProximitySensor
import numpy as np
import pickle
import os
from constants import *
from behaviors import *
import threading
import ctypes
import os
from ros import runros

# Shared data class for multi-threading
class SharedData:

    def __init__(self):

        self.active = False             # bot active flag
        self.dir = "straight"           # direction for manual driving
        self.lock=threading.Lock()      # thread lock
        self.goal = (np.nan, np.nan)    # current goal coordinates
        self.explore = False            # exploration flag
        self.driveto = False            # goal driving flag
        self.step = False               # stepping flag
        self.mode = Mode.PAUSE          # mode Enum
        self.prev_mode =Mode.EXPLORE    # previous mode
        self.filename=''                # map filenames
        self.newpose=False              # new coordinates flag
        self.robotx=0                   # x-coordinate of the bot
        self.roboty=0                   # y-coordinate of the bot
        self.robotheading=0             # heading of the bot
        self.newcommand=False           # new command received flag

    # Acquire lock to shared data
    def acquire(self):
        return self.lock.acquire()
    
    # Release lock shared data
    def release(self):
        self.lock.release()

# Drive the bot according to the tree generated by the Dijkstra's algorithm: Drive to a known goal OR drive towards an unknown goal
def autonomous_drive(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot):
    
    while shared.driveto:

        if (cmap.xpose,cmap.ypose)==cmap.goal: # goal is reached
            cmap.show()   
            cmap.cleartree()
            cmap.goal=(np.nan,np.nan)   # reset goal
            cmap.show()  
            return (1, "done")

        # Return if the next step cannot be executed due to blockage
        if cmap.getintersection().direction in range(8):
            if cmap.getintersection().blocked[cmap.getintersection().direction]:      
                return (0, "blocked")

        # Return if the next step cannot be executed since there's no known path to the goal from the current intersection
        if cmap.getintersection().direction==None or cmap.getintersection().cost == float('inf'):
            return (0, "none")
        
        to_turn =cmap.getintersection().direction-cmap.heading      # angle to be turned (mod 8 heading)

        if abs(to_turn)==4: # need to turn 180 degrees; prioritize the direction which would minimize the no. of turns
            lblocks=0   # streets blocking turning, if turning left
            rblocks=0   # streets blocking turning, if turning right

            # Count the blocking streets in each direction
            for h in range(cmap.heading+1, cmap.heading+4 ):
                if cmap.getintersection().streets[h%8]==STATUS.CONNECTED or cmap.getintersection().streets[h%8]==STATUS.DEADEND:
                    lblocks+=1
            for h in range(cmap.heading-1, cmap.heading-4, -1):
                if cmap.getintersection().streets[h%8]==STATUS.CONNECTED or cmap.getintersection().streets[h%8]==STATUS.DEADEND:
                    rblocks+=1

            if rblocks>lblocks: # more right blocks, so turn left
                to_turn=4
            else:               # else turn right
                to_turn=-4     
        
        elif to_turn>0:         # mod 8 adjustments
            to_turn = to_turn-8 if abs(to_turn)>4 else to_turn

        elif to_turn<0:         # mod 8 adjustments
            to_turn = 8+to_turn if abs(to_turn)>4 else to_turn

        # Execute the drive
        if cmap.getintersection().direction in range(8):

            if to_turn>0 and not cmap.turned:   # turn left
                execute_drive('left', cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            elif to_turn<0 and not cmap.turned: # turn right
                execute_drive('right', cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            elif to_turn == 0 or cmap.turned:   # bot is facing the correct direction OR bot turned recently: go straight
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)

        # If stepping, execute a single loop and break
        if shared.step:
            shared.driveto=False
            shared.explore=False
            shared.active=False

    return (0, "none")  # ensure proper exit 

# Directed exploration towards an unknown/ non-driveable goal
### CURRENTLY NOT OPTIMIZED; At every intersection, turns towards the goal and drives straight ####
def directed_explore(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot):

    while shared.driveto:
        
        # Make a list of all intersections that might contain some information
        to_check=[]
        for intersection in cmap.intersections.values():
            if not intersection.all_explored():
                unexplored_intersection =(intersection.x,intersection.y)
                to_check.append(unexplored_intersection)
        
        if not to_check:
            cmap.clear()
            for intersection in cmap.intersections.values():
                if not intersection.all_explored():
                    unexplored_intersection =(intersection.x,intersection.y)
                    to_check.append(unexplored_intersection)
        
        # Run the dijkstras algorithm; initialize on_deck with the to_check list
        cmap.dijkstras(to_check)
        
        # Drive according to the tree. this will try to get the robot to the goal; if goal is not known yet, then the robot will end up in the cost optimized unexplored intersection
        reached=autonomous_drive(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot)
        
        if reached[0]: 
            print("I FOUND IT")
            return
        
        if reached[1]=="blocked": #handle thissssss
            #print("blocked")
            execute_drive("right", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            continue

        if (cmap.xpose,cmap.ypose)==cmap.goal: #goal is reached
            cmap.show()   #visualize
            cmap.cleartree()
            cmap.goal=(np.nan,np.nan)
            cmap.show()   #visualize
            return

        goal_angle = np.arctan2(cmap.goal[0]-cmap.xpose, cmap.goal[1]-cmap.ypose)*180/np.pi
       # print("goal_angle: ", goal_angle)
        robot_angle = cmap.heading * 45

        robot_angle = -robot_angle if robot_angle<180 else 360-robot_angle
       # print("robot angle ", robot_angle)
        diff = robot_angle-goal_angle

        if diff>180:
            diff = -(360-diff)
        elif diff<-180:
            diff = 360-abs(diff)

        #count the blocking streets in each direction
        l=0   #streets blocking turning, if turning left
        r=0   #streets blocking turning, if turning right
        l_con=0
        r_con=0
        connected_h=[None,None]
        
        for h in range(cmap.heading+1, cmap.heading+4 ):
            if cmap.getintersection().streets[h%8]==STATUS.UNKNOWN:
                l+=1
                if connected_h[0]==None:
                    connected_h[0]=h%8
            if cmap.getintersection().streets[h%8]==STATUS.CONNECTED:
                l_con+=1
                if connected_h[0]==None:
                    connected_h[0]=h%8
        for h in range(cmap.heading-1, cmap.heading-4, -1):
            if cmap.getintersection().streets[h%8]==STATUS.UNKNOWN:
                r+=1
                if connected_h[1]==None:
                    connected_h[1]=h%8
            if cmap.getintersection().streets[h%8]==STATUS.CONNECTED:
                r_con+=1
                if connected_h[1]==None:
                    connected_h[1]=h%8
        if l==0 and r==0:   #if no blocking streets, count the unexplored streets
            for h in range(cmap.heading+1, cmap.heading+4 ):
                if cmap.getintersection().streets[h%8]==STATUS.UNEXPLORED and not cmap.getintersection().blocked[h%8]:
                    l+=1
                    if connected_h[0]==None:
                        connected_h[0]=h%8
            for h in range(cmap.heading-1, cmap.heading-4, -1):
                if cmap.getintersection().streets[h%8]==STATUS.UNEXPLORED and not cmap.getintersection().blocked[h%8]:
                    r+=1
                    if connected_h[1]==None:
                        connected_h[1]=h%8

        if not shared.driveto:
            break

        if diff==0: # goalstraight ahead
            #print("goal straight ahead")
            if cmap.getintersection().streets[cmap.heading] in [STATUS.UNEXPLORED, STATUS.CONNECTED] and not cmap.getintersection().blocked[cmap.heading] :
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            else:
                if l>0:
                    execute_drive("left", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                    execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                else:
                    execute_drive("right", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                    execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)

        elif diff>0: # goal to the left
            #print("goal to the left")
            if l>0:
                execute_drive("left", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            elif l_con>0:
                if not cmap.getintersection().blocked[connected_h[0]]:
                    execute_drive("left", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                    execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                elif cmap.getintersection().streets[cmap.heading] in [STATUS.UNEXPLORED, STATUS.CONNECTED] and not cmap.getintersection().blocked[cmap.heading] :
                    execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                else:
                    execute_drive("right", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                    execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            elif cmap.getintersection().streets[cmap.heading] in [STATUS.UNEXPLORED, STATUS.CONNECTED] and not cmap.getintersection().blocked[cmap.heading] :
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            elif r>0:
                execute_drive("right", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            else:
                execute_drive("right", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)

        elif diff<0:   # goal to the right
            #print("goal to the right")
            if r>0:
                execute_drive("right", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            elif r_con>0:
                if not cmap.getintersection().blocked[connected_h[1]]:
                    execute_drive("right", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                    execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                elif cmap.getintersection().streets[cmap.heading] in [STATUS.UNEXPLORED, STATUS.CONNECTED] and not cmap.getintersection().blocked[cmap.heading] :
                    execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                else:
                    execute_drive("left", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                    execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            elif cmap.getintersection().streets[cmap.heading] in [STATUS.UNEXPLORED, STATUS.CONNECTED] and not cmap.getintersection().blocked[cmap.heading] :
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            elif l>0:
                execute_drive("left", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
            else:
                execute_drive("left", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                execute_drive("straight", cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)

        if (cmap.xpose,cmap.ypose)==cmap.goal: # goal is reached
            cmap.show()   
            cmap.cleartree()
            cmap.goal=(np.nan,np.nan)
            cmap.show()  
            return
        
        # If stepping, execute a single loop and break
        if shared.step:
            shared.driveto=False
            shared.explore=False
            shared.active=False

# Explore the map: collects information and builds the map
def explore(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot):

    cur=cmap.getintersection()  # begin with current intersection

    while shared.explore:

        if not cur.all_explored() and not cmap.turned:  # current intersection unexplored and the bot did not recently turn

            l=0   # UNKNOWN streets to the left
            r=0   # UNKNOWN streets to the right

            # Count the UNKNOWN streets in either direction
            for h in range(cmap.heading+1, cmap.heading+5):
                if cmap.getintersection().streets[h%8]==STATUS.UNKNOWN:
                    l+=1
            for h in range(cmap.heading-1, cmap.heading-4, -1):
                if cmap.getintersection().streets[h%8]==STATUS.UNKNOWN:
                    r+=1

            if l==0 and r==0:   # no UNKNOWN streets: count the UNEXPLORED streets
                for h in range(cmap.heading+1, cmap.heading+5):
                    if cmap.getintersection().streets[h%8]==STATUS.UNEXPLORED and not cmap.getintersection().blocked[h%8]:
                        l+=1
                for h in range(cmap.heading-1, cmap.heading-4, -1):
                    if cmap.getintersection().streets[h%8]==STATUS.UNEXPLORED and not cmap.getintersection().blocked[h%8]:
                        r+=1
            
            if l==0 and r==0:   # no streets to explore on the sides: go straight
                execute_drive("straight",cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                cur=cmap.getintersection()  # update intersection

            elif l>r:   # more left streets to be explored/known: turn left
                execute_drive('left',cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)

            else:   # more right streets to be explored/known: turn right
                execute_drive('right',cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)

        elif not cur.all_explored() and cmap.turned:     # current intersection unexplored, but the bot recently turned

            execute_drive("straight",cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)    # drive straight to avoid multiple consecutive turns
            cur=cmap.getintersection()  # update intersection

        elif cur.all_explored():    # current intersection is fully explored. 
            
            # Find the unexplored intersection with minimum cost of driving 
            min_dist = 1e4
            next = None         # the nearest unexplored intersection with minimal driving cost
            cmap.goal=(cur.x, cur.y)    
            cmap.dijkstras()       # implement Dijkstra's to current intersection to find the minimal driving cost
            to_check=0              # no. of unexplored intersections
            for intersection in cmap.intersections.values():   
                if not intersection.all_explored():
                    to_check+=1
                    dist = intersection.cost
                    dir = intersection.direction
                    if dir != None:     # driveable
                        if dist<min_dist and dist!=0:
                            next = intersection
                            min_dist=dist

            cmap.cleartree()       # clear the Dijkstra's tree
            cmap.goal = (np.nan, np.nan)

            if to_check==0:         # all intersections have been explored upto a limit of driveablity along streets
                print("All explored!")
                cmap.show()
                return
            
            if next== None: # there are unexplored intersections, but no paths
                cmap.clear()    # clear blockages and try again
            else:
                cmap.goal = (next.x, next.y)
                cmap.dijkstras()
                shared.driveto=True
                reached = autonomous_drive(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot)
                cmap.goal = (np.nan, np.nan)
                cur=cmap.getintersection()

        # If stepping, execute a single loop and break  
        if shared.step:
            shared.explore=False
            shared.driveto=False
            shared.active=False

# Save the intersections dictionary as a .pickle file
def savepickle(intersections, filename):

    if filename[len(filename)-7:]!='.pickle':   #add extension
        filename+='.pickle'

    # Save the map to file.
    print("\n Saving the map as %s..." % filename)
    filepath=os.path.join(cur_dir, 'maps/'+filename)
    with open(filepath, 'wb') as file:
        pickle.dump(intersections, file)

# Retrieve a pre-existing .pickle file (map)
def getpickle(filename):

    # Load the map from file.
    maps= os.listdir(map_filenames) 
    if filename not in maps:    # invalid filename
        print("\n"+filename+ " does not exist!")
        return None
    
    filepath=os.path.join(cur_dir, 'maps/'+filename)
    print("\n Loading the map from %s..." % filename)
    with open(filepath, 'rb') as file:
        intersections = pickle.load(file)

    return intersections

# Execute turns and drives and update the map with any new information
def execute_drive(dir, cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared):

    if dir in ["left", "right"]:    # turn

        cmap.turned= True  # recently turned flag (markes True regardless of whether inside a tunnel for consistency)

        if cmap.getintersection().tunnel:   # do not turn if the intersection is inside a tunnel
            return
        
        hold=cmap.heading    # previous heading of the bot
        turn_angle=turn(bot,line_sensor,angle_sensor, dir)  # turn the bot in the specified direction
        cmap.update_using_turn(dir, turn_angle, hold)   # update map based on the turning angle
        obstacle_ahead=check_ahead(proximity_sensor,cmap.heading)   # check for blockages in the current heading
        cmap.update_using_checkahead(obstacle_ahead)    # update map based on ultrasound sensor readings
    
    else:

        cmap.turned= False  # recently turned flag

        obstacle_ahead=check_ahead(proximity_sensor,cmap.heading)   # check for blockages in the current heading
        cmap.update_using_checkahead(obstacle_ahead)    # update map based on ultrasound sensor readings
    
        # Return if there's no street ahead or it is blocked
        if cmap.getintersection().streets[cmap.heading]==STATUS.NONEXISTENT or cmap.getintersection().blocked[cmap.heading]:
            cmap.show()
            return 
        
        result = smartlinefollow(bot, line_sensor, proximity_sensor, angle_sensor)  # execute line\tunnelfollowing behavior

        if result[0]=="INTERSECTION":   # robot successfully reached an intersection

            street_ahead=pullforward(bot, line_sensor) # pull forward behavior to align the wheels with the intersection
            cmap.update_intersection(result[1])     # update map 

            if result[1]:   # in tunnel
                street_ahead="STREET"
            cmap.update_using_pullforward(street_ahead) # update map based on information received during pullforward behavior about the existence of a street ahead

            obstacle_ahead=check_ahead(proximity_sensor,cmap.heading)   # check for blockages in the current heading
            cmap.update_using_checkahead(obstacle_ahead)    # update map based on ultrasound sensor readings
        
        elif result[0]=="END":  # robot reached deadend and came back to the originating intersection

            street_ahead = pullforward(bot, line_sensor)    # pull forward behavior to align the wheels with the intersection
            cmap.getintersection().streets[cmap.heading]=STATUS.DEADEND  # update map 
            cmap.calcturn(-180, "right", True)      # update heading
            cmap.update_using_pullforward(street_ahead)   # update map based on information received during pullforward behavior

        elif result=="OBSTACLE":    # encountered an obstacle mid-way and u-turned to the original intersction

            street_ahead = pullforward(bot, line_sensor) # pull forward behavior to align the wheels with the intersection
            cmap.update_using_checkahead("OBSTACLE")    # update street as blocked
            cmap.calcturn(-180, "right", True)      # update heading
            cmap.update_using_pullforward(street_ahead)      # update map based on information received during pullforward behavior
            obstacle_ahead=check_ahead(proximity_sensor,cmap.heading)   # check for blockages in the current heading
            cmap.update_using_checkahead(obstacle_ahead)    # update map based on ultrasound sensor readings
    
    # Update pose after every drive
    if shared.acquire():
        shared.robotx=cmap.xpose
        shared.roboty=cmap.ypose
        shared.robotheading=cmap.heading
        shared.release()

    cmap.show() # update the plot and save

# User Interface thread
def ui(shared):

    try:
        running = True
        while running:
            command=input("Enter a command: 'explore', 'goal', 'pause', 'step', 'resume', 'left', 'right', 'straight', 'save', 'load', 'pose', 'quit', 'clear'")
            if shared.acquire():
                if command == 'explore':
                    shared.prev_mode=shared.mode
                    shared.explore=True
                    shared.driveto=False
                    shared.mode = Mode.EXPLORE
                    shared.active = True
                    shared.step=False
                    shared.newcommand=True
                elif command.split()[0] == 'goal':
                    shared.prev_mode=shared.mode
                    shared.explore=False
                    shared.driveto=False
                    shared.goal = tuple(map(int, command.split()[1:]))
                    shared.mode = Mode.DRIVETO
                    shared.step=False
                    shared.active = True
                    shared.newcommand=True
                elif command == 'pause':
                    shared.driveto=False
                    shared.explore=False
                    shared.active =False
                    shared.newcommand=True
                elif command == 'step':
                    if not shared.driveto and not shared.explore:
                        if shared.mode == Mode.EXPLORE:
                            shared.explore=True
                            shared.active =True
                        elif shared.mode == Mode.DRIVETO:
                            shared.driveto=True
                            shared.active =True
                        shared.step=True
                    shared.newcommand=True
                elif command == 'resume':
                    if not shared.driveto and not shared.explore:
                        if shared.mode == Mode.EXPLORE:
                            shared.explore=True
                            shared.active =True
                            shared.newcommand=True
                        elif shared.mode == Mode.DRIVETO:
                            shared.driveto=True
                            shared.active =True
                            shared.newcommand=True
                        shared.step=False
                elif command in ['left', 'right', 'straight']:
                    shared.dir=command
                    shared.prev_mode=shared.mode
                    shared.mode = Mode.MANUAL
                    shared.driveto=False
                    shared.explore=False
                    shared.step=False
                    shared.active =True
                    shared.newcommand=True
                elif command.split()[0] == 'save':
                    shared.filename = command.split()[1]
                    shared.prev_mode=shared.mode
                    shared.mode=Mode.SAVE
                    shared.active=True
                    shared.newcommand=True
                    shared.driveto=False
                    shared.explore=False
                    shared.newcommand=True
                elif command.split()[0] == 'load':
                    shared.prev_mode=shared.mode
                    shared.filename = command.split()[1]
                    if shared.filename =='n':
                        x, y, robotheading = tuple(map(int, command.split()[2:]))
                        shared.robotx = x
                        shared.roboty = y
                        shared.robotheading = robotheading
                        shared.newpose=True
                    shared.mode=Mode.LOAD
                    shared.active=True
                    shared.newcommand=True
                elif command.split()[0] == 'pose':
                    x, y, robotheading = tuple(map(int, command.split()[1:]))
                    shared.robotx = x
                    shared.roboty = y
                    shared.robotheading = robotheading
                    shared.newpose=True
                elif command == 'quit':
                    shared.driveto=False
                    shared.explore=False
                    shared.step=False
                    running=False
                elif command == 'clear':
                    shared.prev_mode=shared.mode
                    shared.mode = Mode.CLEAR
                    shared.active=True
                    shared.newcommand=True
                    shared.active=True
                    shared.newcommand=True
                    shared.driveto=False
                    shared.explore=False
                    shared.newcommand=True
                else:
                    shared.newcommand=False
                    print('Illegal command '+ command)
                shared.release()
    except BaseException as ex:
        print("Ending UI due to exception: %s" % repr(ex))

# Robot thread to run the main robot code
def runrobot(shared, bot, angle_sensor, line_sensor, cmap, proximity_sensor):

    cmap.show()

    # Variables to store and utilize shared data
    goal = (np.nan, np.nan)
    dir ="straight"
    active = False
    newpose=False
    robotx=0
    roboty=0
    robotheading=0

    try:
        while True:

            # Acquire and update from shared data
            if shared.acquire():

                mode=shared.mode
                prev_mode=shared.prev_mode
                dir=shared.dir
                goal= shared.goal
                filename=shared.filename

                # Check for new commands: pause the bot if no new command.
                if shared.newcommand:
                    active=shared.active
                    shared.newcommand=False
                else:
                    active=False
                
                # Check for new pose set
                if shared.newpose:
                    newpose=True
                    robotx=shared.robotx
                    roboty=shared.roboty
                    robotheading=shared.robotheading
                    shared.newpose=False

                shared.release() 
            
            # Update the new pose data 
            if newpose:
                cmap.xpose=robotx
                cmap.ypose=roboty
                cmap.heading=robotheading
                cmap.show()   
                newpose=False

            if not active:  # pause the bot
                bot.stop()

            elif mode ==Mode.SAVE:

                # Clear any trees and save the map as a pickle file to \maps
                cmap.cleartree()
                savepickle(cmap.intersections, filename)

                # Continue with previous modes, if any
                if prev_mode == Mode.EXPLORE:
                    if shared.acquire():
                        shared.mode=Mode.EXPLORE
                        shared.explore=True
                        shared.active =True
                        shared.newcommand=True
                        shared.release()
                elif prev_mode == Mode.DRIVETO:
                    if shared.acquire():
                        shared.mode =Mode.DRIVETO
                        shared.driveto=True
                        shared.active =True
                        shared.newcommand=True
                        shared.release()

            elif mode==Mode.LOAD:

                if filename == 'n':   

                    # Load an empty map, drive the bot to an intersection, and set the robot pose
                    cmap=Map({})
                    street_ahead=initialize_robot(bot, line_sensor, proximity_sensor)
                    cmap.xpose=robotx
                    cmap.ypose=roboty
                    cmap.heading=robotheading
                    _=cmap.getintersection()  
                    cmap.update_using_pullforward(street_ahead)
                    cmap.show()

                elif getpickle(filename)!= None:

                    # Load map from an existing pickle file
                    cmap=Map(getpickle(filename))
                    cmap.cleartree()
                    cmap.show()

            elif mode == Mode.MANUAL:

                # Manual driving based on user input
                execute_drive(dir, cmap, proximity_sensor, line_sensor, angle_sensor, bot, shared)
                cmap.cleartree()

            elif mode == Mode.DRIVETO:

                # Drive to a known/unknown goal 
                if goal in cmap.intersections:  # known goal

                    # Clear blockages, implement Dijkstras.
                    cmap.clear()
                    cmap.goal=goal
                    cmap.dijkstras()
                    shared.driveto=True
                    reached = (0, "dummy")

                    # Drive to the goal.
                    while shared.driveto:

                        reached = autonomous_drive(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot)

                        if reached[0]:  # goal reached
                            break
                        if reached[1]=='none':  # no known paths to goal: explore find a new path
                            directed_explore(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot)
                        else:           # path is blocked: reimplement Dijkstra's algorithm to find a driveable known path
                            cmap.dijkstras()

                else:   # unknown goal

                    cmap.goal=goal
                    shared.driveto=True
                    cmap.clear()
                    directed_explore(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot)    # find a new path to the goal

                cmap.goal=(np.nan, np.nan)  # erase goal

            elif mode == Mode.EXPLORE:

                # Clear blockages and explore tha map to obtain information
                cmap.clear()
                cmap.show()
                explore(cmap, shared, proximity_sensor, line_sensor, angle_sensor, bot)   

            elif mode == Mode.CLEAR:

                # Clear all existing blockages
                cmap.clear()
                cmap.show()

                # Continue with previous mode, if any
                if prev_mode == Mode.EXPLORE:
                    if shared.acquire():
                        shared.mode=Mode.EXPLORE
                        shared.explore=True
                        shared.active =True
                        shared.newcommand=True
                        shared.release()
                elif prev_mode == Mode.DRIVETO:
                    if shared.acquire():
                        shared.mode =Mode.DRIVETO
                        shared.driveto=True
                        shared.active =True
                        shared.newcommand=True
                        shared.release()

    except BaseException as ex:
        print("Ending Worker due to exception: %s" % repr(ex))

# Initialize the robot everytime an empty map is loaded
def initialize_robot( bot, line_sensor, proximity_sensor):

    # Drive the robot until it finds and intersection
    result = linefollow(bot,line_sensor, proximity_sensor)
    while result[0]!= "INTERSECTION":    
        turn_angle= turn(bot,line_sensor,angle_sensor, "right")   # spin back to line
        result = linefollow(bot,line_sensor, proximity_sensor) 

    street_ahead=pullforward(bot, line_sensor)  # pullforward after reaching the intersection

    return street_ahead

# Main code
if __name__ == "__main__":

    # Setup GPIOs
    print("Setting up the GPIO...")
    io = pigpio.pi()
    if not io.connected:
        print("Unable to connection to pigpio daemon!")
        sys.exit(0)
    print("GPIO ready...")

    # Initialize hardware component objects
    bot=DriveSystem(left_forward_leg, left_reverse_leg, right_forward_leg, right_reverse_leg, max_pwm, pwm_frequency, io)   # motorsystem   
    angle_sensor=AngleSensor( LATCH, ADDRESS, READY, PINS, io)                                                              # magnetometer
    line_sensor=LineSensor(IR_left_pin, IR_mid_pin, IR_right_pin, io)                                                       # IR sensor system
    proximity_sensor = ProximitySensor(io, trig_pins, echo_pins)                                                            # ultrasound sensor system
    
    # Create shared data object for threads
    shared=SharedData()

    # Create an empty map and visualize
    cmap = Map({})
    cmap.show()
        
    # Initialization 
    street_ahead = initialize_robot(bot, line_sensor, proximity_sensor)

    # Userinput for the current position of the bot
    pose = tuple(int(i) for i in input("Enter my x-coordinate, y-coordinate, and robotheading: ").split())  
    while len(pose)!=3:     # validate user input for current pose
        pose = tuple(int(i) for i in input('Input valid x, y and robotheading').split())

    (cmap.xpose,cmap.ypose,cmap.heading)=pose[0],pose[1],pose[2]   # set pose

    # Update shared data with pose
    if shared.acquire():
        (shared.robotx, shared.roboty, shared.robotheading)=cmap.xpose,cmap.ypose,cmap.heading
        shared.release()

    _=cmap.getintersection()  # initialize intersection at current pose
    cmap.update_using_pullforward(street_ahead) # update current intersection using pull forward information
    
    # Start the ROS worker thread.
    rosthread = threading.Thread(name="ROSThread", target=runros, args=(shared,))
    rosthread.start()

    # Create and start the robot thread
    robot_thread = threading.Thread(target=runrobot, args=(shared, bot, angle_sensor, line_sensor, cmap, proximity_sensor))
    robot_thread.start()
    ui(shared)

    # Send keyboard exception to end the robot thread
    ctypes.pythonapi.PyThreadState_SetAsyncExc(
            ctypes.c_long(robot_thread.ident),
            ctypes.py_object(KeyboardInterrupt))
    
    # Wait for the robot thread to finish
    robot_thread.join()
    
    # End the ROS thread (send the KeyboardInterrupt exception).
    ctypes.pythonapi.PyThreadState_SetAsyncExc(
    ctypes.c_long(rosthread.ident), ctypes.py_object(KeyboardInterrupt))
    rosthread.join()

    # Shutdown ultrasound sensor threads, stop the bot, and disable the ios
    proximity_sensor.shutdown()
    bot.stop()
    io.stop()